import order.filter
import for_mathlib.boolean_subalgebra

/-
We say a filter F *decides* a set S if either S or Sᶜ belongs to F.
The sets decided by a filter form a boolean subalgebra.
For a fixed boolean subalgebra A, an *ultrafilter on A*
is a filter which decides every member of A.
To check that a filter F is an ultrafilter on A,
it then suffices to check that it decides the members
of a family of elements of A which generate it as a boolean subalgebra.

An ultrafilter in the mathlib sense is the same as
an ultrafilter on the boolean algebra of all sets.
-/

variables {α : Type*}

namespace filter

def decides (f : filter α) (s : set α) : Prop :=
s ∈ f ∨ sᶜ ∈ f

variables {f : filter α} {s t : set α}

lemma decides_empty : f.decides ∅ :=
or.inr (by { convert f.univ_sets, simp })

lemma decides.union (hs : f.decides s) (ht : f.decides t) :
  f.decides (s ∪ t) :=
begin
  -- If either s or t belongs to f, then so does s ∪ t
  cases hs,
  { left, apply f.sets_of_superset hs (set.subset_union_left _ _) },
  cases ht,
  { left, apply f.sets_of_superset ht (set.subset_union_right _ _) },
  -- Otherwise, both sᶜ and tᶜ belong to f
  right,
  rw set.compl_union,
  apply f.inter_sets hs ht
end

lemma decides.compl (hs : f.decides s) : f.decides (sᶜ) :=
begin
  unfold decides,
  rw [or_comm, set.compl_compl],
  exact hs
end

lemma is_boolean_subalgebra_decides : is_boolean_subalgebra f.decides :=
⟨decides_empty, λ _ _, decides.union, λ _, decides.compl⟩

/-- If a filter decides every member of S, then it also decides
every member of the boolean subalgebra generated by S. -/
lemma decides_gen {S : set (set α)} (h : ∀ s ∈ S, f.decides s) :
  ∀ {t : set α}, t ∈ boolean_subalgebra.gen S → f.decides t :=
(boolean_subalgebra.gen_subset_iff_subset is_boolean_subalgebra_decides).mpr h

end filter
